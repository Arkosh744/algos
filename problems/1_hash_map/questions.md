### Вопросы для самостоятельного изучения

**Для общего развития**

- Какие есть виды хеш-функций, чем они отличаются и по каким критериям можно выбирать хеш функцию в зависимости от
  задачи?

Хеш-функции различаются по своим свойствам и применяются в зависимости от задачи. Основные виды хеш-функций:

Криптографические хеш-функции: используются для безопасности данных. Они обеспечивают такие свойства, как устойчивость
к коллизиям (случай, когда два разных входа дают один и тот же хеш), необратимость и односторонность. Примеры включают
SHA-256, SHA-3, а также устаревший MD5. Эти функции применяются в криптографии, для цифровых подписей и проверки
целостности данных.

Некриптографические хеш-функции: предназначены для быстрого хеширования и оптимального распределения данных в таких
структурах, как хеш-таблицы. Эти функции менее защищены, но более производительны по сравнению с криптографическими
аналогами. Примеры — FNV, MurmurHash, CityHash. Такие функции используют для кеширования, индексации и распределения
нагрузки.

Универсальные хеш-функции: рассчитаны на равномерное распределение данных независимо от их структуры и состава. Их
цель — минимизировать вероятность коллизий для любого набора данных. Примеры включают хеширование на основе умножения
и табличного поиска.

Критерии выбора хеш-функции:

1. Скорость: для высокопроизводительных систем лучше всего подходят некриптографические функции, так как они
   обеспечивают быстрое хеширование без излишней нагрузки.
2. Равномерное распределение: для минимизации коллизий и равномерного распределения данных в структурах, таких как
   хеш-таблицы, важен баланс, обеспечиваемый алгоритмом.
3. Устойчивость к коллизиям: требуется в задачах, где хеш-коды часто пересчитываются, например, в структурах типа
   блумфильтров.
4. Безопасность: при хранении или передаче конфиденциальных данных применяются криптографические хеш-функции с сильной
   устойчивостью к коллизиям и атаке методом перебора.
5. Размер выходных данных: может быть важен для оптимизации памяти, особенно в ограниченных системах, где меньшие хеши
   помогают снизить потребление ресурсов.

Выбор хеш-функции зависит от специфических требований задачи, включая баланс между скоростью, безопасностью и объемом
данных. Например, в большинстве задач распределения данных некриптографические функции, такие как MurmurHash или
CityHash, обеспечат оптимальную производительность.
___

- Какая хеш-функция используется для генерации JWT и как происходит процесс верификации? Чем отличается хеш-функция (
  алгоритм цифровой подписи) генерации JWT от классической хеш-функции по типу MD5

JWT (JSON Web Token) — это стандарт передачи данных между участниками с использованием JSON-объекта. Для обеспечения
безопасности JWT подписывается, что позволяет его верифицировать.

Хеш-функции и алгоритмы подписи в JWT: JWT может использовать несколько алгоритмов для подписи токенов:

    HMAC (Hash-based Message Authentication Code): например, HS256, HS384, HS512. Этот метод объединяет криптографическую хеш-функцию (обычно SHA-256) с секретным ключом. Токен подписывается секретом, который известен только отправителю и получателю.

    RSA (Rivest–Shamir–Adleman): примеры — RS256, RS384, RS512. Этот метод использует асимметричную криптографию с открытым и закрытым ключом, где подпись создается с использованием закрытого ключа и проверяется по открытому. RSA позволяет безопасно работать с несколькими сторонами, так как открытый ключ можно распространять публично.

    ECDSA (Elliptic Curve Digital Signature Algorithm): примеры — ES256, ES384, ES512. Этот метод использует эллиптические кривые для создания более компактных и эффективных ключей при аналогичном уровне безопасности с RSA.

    PS (RSASSA-PSS): примеры — PS256, PS384, PS512. Вариант RSA, обеспечивающий повышенную безопасность.

Процесс генерации и верификации JWT:

    Генерация:
        Формируется заголовок с информацией о типе токена и алгоритме подписи.
        Создается полезная нагрузка, содержащая утверждения (claims), например, идентификацию пользователя или срок действия.
        Генерируется подпись: объединяются заголовок и полезная нагрузка и подписываются с использованием заданного алгоритма.
    Верификация:
        Декодируются заголовок и полезная нагрузка.
        Проверяется подпись с помощью алгоритма и ключа. Например, для HMAC это означает проверку подписи при помощи вычисленного и присланного значений.

Отличия от классических хеш-функций:

    Цель: Хеш-функции типа MD5 или SHA-256 создают хеш-значение для проверки целостности данных, но не обеспечивают подлинность данных.
    Аутентификация: JWT использует криптографическую подпись, которая делает токен аутентифицируемым, в отличие от обычных хеш-функций, которые этого не обеспечивают.
    Ключ: Подпись JWT включает секретный или закрытый ключ для безопасности, чего нет у хеш-функций типа MD5.

Таким образом, JWT применяет алгоритмы подписи, чтобы хешировать данные с добавлением механизма аутентификации для
проверки целостности и подлинности данных.

___

- Что такое консистентное хеширование и как оно применяется при решардинге?

Консистентное хеширование — это метод распределения данных между множеством узлов в распределенной системе,
предназначенный для эффективного управления нагрузкой и минимизации перемещений данных при изменении числа узлов. Этот
подход полезен в распределенных базах данных и кеш-системах, так как позволяет гибко распределять нагрузку.

Основные идеи консистентного хеширования:

    Круговое распределение: узлы и ключи располагаются на кольце хеш-диапазона, а каждый ключ направляется на ближайший узел по часовой стрелке от своей позиции.

    Преимущества:
        Минимизация перемещений данных: при добавлении или удалении узлов перераспределяется только часть данных, что снижает нагрузку.
        Балансировка нагрузки: с помощью виртуальных узлов можно распределить ключи более равномерно, чтобы избежать перегрузки отдельных узлов.

Процесс консистентного хеширования:

    Хеширование узлов: каждый узел хешируется для определения позиции на кольце. Использование хеш-функции, например, SHA-1, помогает детерминированно расположить узлы.

    Хеширование ключей: каждый ключ хешируется и размещается на кольце.

    Назначение ключей узлам: каждый ключ направляется на ближайший по часовой стрелке узел, что позволяет избежать потерь при добавлении/удалении узлов.

Решардинг и консистентное хеширование:

    Добавление узла: новый узел хешируется и добавляется на кольцо. Только те ключи, что попадают в его область, переназначаются ему, минимизируя изменения.

    Удаление узла: узел удаляется с кольца, а ключи, которые обслуживались им, переназначаются следующему узлу по часовой стрелке.

Примеры применения:

    Кеширование: в системах, таких как Redis, консистентное хеширование помогает распределить кешированные данные равномерно между серверами.
    Базы данных: такие системы, как Apache Cassandra, используют консистентное хеширование для распределения данных по кластеру.
    Системы хранения: Amazon DynamoDB использует этот метод для управления данными между узлами.

Итоги: Консистентное хеширование делает систему более гибкой и устойчивой, минимизируя перемещения данных при добавлении
или удалении узлов.

___

**Коллизии**

- Что такое коллизия?  
  Коллизия — это ситуация, возникающая при хешировании, когда два разных ключа (входных данных) получают одинаковое
  хеш-значение. Коллизии являются обычным явлением в хеш-таблицах, где ограниченное количество слотов используется для
  хранения большого числа элементов. Основная задача при проектировании хеш-таблицы — разрешение коллизий, так как они
  могут привести к снижению производительности или даже к потере данных.

___

- Какие есть методы разрешения коллизии и их плюсы и минусы?

**Открытая адресация**  
Суть: При коллизии новый элемент записывается в ближайший свободный слот, найденный с помощью определенной
стратегии (например, линейного пробирования).  
+: Простота реализации, эффективное использование памяти, отсутствие дополнительной структуры для хранения.  
-: Могут возникать проблемы с кластеризацией, что приводит к замедлению поиска. Эффективность резко падает при
высокой заполненности таблицы.

**Метод цепочек (открытое хеширование)**  
Суть: Каждое значение, которое попадает в один и тот же слот, добавляется в связный список (или другую структуру,
например, дерево).  
+: Легче справляется с высокой степенью заполнения таблицы, так как количество элементов в списках увеличивается,
но не страдает время доступа к другим слотам.  
-: Использует дополнительную память для хранения ссылок, что увеличивает потребление памяти. Сложность поиска и
удаления элементов в цепочке может увеличиваться.

**Двойное хеширование**   
Суть: Для каждой коллизии используется вторая хеш-функция, которая определяет шаг перемещения.  
+: Снижает кластеризацию, увеличивая разброс данных, работает быстрее линейного пробирования.  
-: Зависит от качества второй хеш-функции, а также требует больше вычислений.
___

- Какие плюсы и минусы и методов разрешения коллизии таких как “открытая адресация“ и “метод цепочек“

Открытая адресация

    Плюсы:
        Легкость и компактность реализации, так как не требует дополнительных структур.
        Подходит для систем с ограниченной памятью и не требует выделения памяти для новых элементов.
    Минусы:
        При высоком коэффициенте заполнения (например, >70%) возникают проблемы с кластеризацией и замедляется время поиска.
        Удаление элементов может требовать реорганизации таблицы или создания "кладбища" (место хранения для удаленных элементов), что усложняет алгоритм.

Метод цепочек (открытое хеширование)

    Плюсы:
        Лучше справляется с коллизиями в сильно заполненной таблице, так как каждое место может хранить любое количество элементов.
        Легче управлять удалением элементов, так как не нужно перестраивать всю таблицу.
    Минусы:
        Дополнительные затраты на память для хранения цепочек.
        Производительность поиска может деградировать, если в одном слоте окажется много элементов (особенно при слабой хеш-функции).

___

- Что такое пробирование? Какие есть популярные методы пробирования в таком алгоритме разрешения коллизий как “открытая
  адресация“

Пробирование — это метод поиска следующего свободного слота для размещения элемента при коллизии в методе открытой
адресации. Вместо создания связного списка, как в методе цепочек, элемент перемещается к следующему свободному слоту по
определенной схеме пробирования. Пробирование в открытой адресации бывает разных видов, в зависимости от способа поиска
нового слота.

Популярные методы пробирования:

    Линейное пробирование
        Суть: При коллизии перемещаемся на следующий слот с фиксированным шагом, например, index = (index + 1) % table_size.
        Плюсы: Простая и быстрая реализация.
        Минусы: Приводит к кластеризации, так как элементы с одинаковым начальным хеш-значением образуют цепочку (primary clustering).

    Квадратичное пробирование
        Суть: Шаг увеличивается квадратично, например, index = (index + i^2) % table_size, где i — номер шага.
        Плюсы: Снижает проблему кластеризации, делает распределение элементов более равномерным.
        Минусы: Квадратичное пробирование не всегда охватывает все слоты, особенно если размер таблицы не является простым числом.

    Двойное хеширование
        Суть: Используется вторая хеш-функция, которая определяет шаг при перемещении в поиске свободного слота, например, index = (index + i * hash2(key)) % table_size.
        Плюсы: Наиболее эффективно уменьшает кластеризацию, так как различные элементы получают разные шаги.
        Минусы: Сложнее в реализации и требует тщательно подобранных хеш-функций.

___

**Взлом**

1. Что такое атака на хеш-функцию? Какие есть виды атак? Какие цели у каждой атаки? Так же приведи примеры таких атак
2. Что такое строка Туэ-Морса и какое влияние она может оказать на производительность хеш-таблицы?

**Оптимизации в хеш-таблице**

1. Что такое фильтр блюма? Зачем он используется и как применяется в хеш-таблице? Когда фильтр Блюма лучше всего себя
   покажет - когда мы можем только добавлять в хеш-таблицу элементы или когда есть так же операция удаления?
2. Что такое load factor в хеш-таблицы и как он влияет на производительность?
3. Как бороться с частой реалокацией в хеш-таблице если часто добавляются и удаляются элементы, что приводит к не
   оптимально работой с памятью? Рассмотри сценарий, когда максимальный размер хеш-таблицы 512 элементов, но при этом за
   частую число элементов часто меняется и скачет между 128-512, что вызывает частую реалокацию

**Реализация хеш-сета через int32**

1. Как можно реализовать хеш-сет на битовых операциях и уместить в одном int32, если всего есть не более 32 различных
   элементов, которые мы можем добавить в хеш-сет
2. Как реализовать операции union и intersect через битоваые операции если у нас хеш-сет раcполагается в одном int32?